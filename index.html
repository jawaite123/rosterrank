<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#0f172a">
  <meta name="description" content="Rate and track your softball team's players with detailed scoring metrics">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="RosterRank">
  <link rel="manifest" href="/rosterrank/manifest.json">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect fill='%230f172a' width='180' height='180' rx='40'/><text x='50%' y='55%' font-size='70' fill='%23f59e0b' text-anchor='middle' dominant-baseline='central' font-weight='bold'>RR</text></svg>">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect fill='%230f172a' width='180' height='180' rx='40'/><text x='50%' y='55%' font-size='70' fill='%23f59e0b' text-anchor='middle' dominant-baseline='central' font-weight='bold'>RR</text></svg>">
  <title>RosterRank - Player Analytics</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script>
    // Firebase configuration - Replace with your Firebase project config
    const firebaseConfig = {
      apiKey: "AIzaSyCBRw7vvxAFtx5q5dN0G70Xde_JX7ZqGdQ",
      authDomain: "rosterrank-37d0a.firebaseapp.com",
      projectId: "rosterrank-37d0a",
      storageBucket: "rosterrank-37d0a.firebasestorage.app",
      messagingSenderId: "98560724581",
      appId: "1:98560724581:web:eb451ba3ff560d11da808c"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // Enable offline persistence
    db.enablePersistence().catch((err) => {
      if (err.code === 'failed-precondition') {
        console.log('Multiple tabs open, persistence only enabled in one tab.');
      } else if (err.code === 'unimplemented') {
        console.log('Browser does not support persistence.');
      }
    });
  </script>
  <style>
    /* iOS PWA status bar background */
    html, body {
      background: #0f172a;
    }
    /* Safe area padding for notch and home indicator */
    .safe-area-top {
      padding-top: env(safe-area-inset-top);
    }
    .safe-area-bottom {
      padding-bottom: env(safe-area-inset-bottom);
    }
    /* Prevent text size adjustment on orientation change */
    html {
      -webkit-text-size-adjust: 100%;
    }
    /* Custom slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      height: 24px;
      width: 24px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: 3px solid currentColor;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    input[type="range"]::-moz-range-thumb {
      height: 24px;
      width: 24px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: 3px solid currentColor;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Lucide React icons as inline SVGs
    const Trash2 = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <polyline points="3 6 5 6 21 6"></polyline>
        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        <line x1="10" y1="11" x2="10" y2="17"></line>
        <line x1="14" y1="11" x2="14" y2="17"></line>
      </svg>
    );

    const Plus = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
    );

    const Download = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="7 10 12 15 17 10"></polyline>
        <line x1="12" y1="15" x2="12" y2="3"></line>
      </svg>
    );

    const Upload = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
      </svg>
    );

    const Edit2 = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
      </svg>
    );

    const Save = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
        <polyline points="17 21 17 13 7 13 7 21"></polyline>
        <polyline points="7 3 7 8 15 8"></polyline>
      </svg>
    );

    const X = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    );

    const AlertCircle = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="8" x2="12" y2="12"></line>
        <line x1="12" y1="16" x2="12.01" y2="16"></line>
      </svg>
    );

    const CheckCircle = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
        <polyline points="22 4 12 14.01 9 11.01"></polyline>
      </svg>
    );

    const Sparkles = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"></path>
        <path d="M5 3v4"></path>
        <path d="M19 17v4"></path>
        <path d="M3 5h4"></path>
        <path d="M17 19h4"></path>
      </svg>
    );

    const Cloud = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"></path>
      </svg>
    );

    const CloudOff = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="m2 2 20 20"></path>
        <path d="M5.782 5.782A7 7 0 0 0 9 19h8.5a4.5 4.5 0 0 0 1.307-.193"></path>
        <path d="M21.532 16.5A4.5 4.5 0 0 0 17.5 10h-1.79A7.008 7.008 0 0 0 10 5.07"></path>
      </svg>
    );

    const Loader = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <line x1="12" y1="2" x2="12" y2="6"></line>
        <line x1="12" y1="18" x2="12" y2="22"></line>
        <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
        <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
        <line x1="2" y1="12" x2="6" y2="12"></line>
        <line x1="18" y1="12" x2="22" y2="12"></line>
        <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line>
        <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>
      </svg>
    );

    const Undo = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M3 7v6h6"></path>
        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path>
      </svg>
    );

    const Star = ({ size = 24, className = "", filled = false }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill={filled ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
      </svg>
    );

    function SoftballPlayerRater() {
      const [players, setPlayers] = useState([]);
      const [modal, setModal] = useState({ visible: false, title: '', message: '', onAction: null, actionLabel: '', isImportHelp: false });
      const [updateModal, setUpdateModal] = useState(false);
      const [editingId, setEditingId] = useState(null);
      const [appVersion, setAppVersion] = useState(null);
      const [changelog, setChangelog] = useState({});
      const [currentPlayer, setCurrentPlayer] = useState({
        number: '',
        hitting: 5,
        popfly: 5,
        fielding: 5,
        throwing: 5,
        comments: '',
        starred: false
      });
      const [userId, setUserId] = useState(null);
      const [isLoading, setIsLoading] = useState(true);
      const [syncStatus, setSyncStatus] = useState('offline'); // 'synced', 'syncing', 'offline', 'error'
      const [deletedPlayer, setDeletedPlayer] = useState(null); // For undo functionality
      const hasMigratedRef = useRef(false); // Track if we've done initial migration
      const undoTimeoutRef = useRef(null); // Track undo timeout
      const fileInputRef = useRef(null); // For CSV import

      // Load changelog from external file
      useEffect(() => {
        // Try both paths - production (/rosterrank/) and local (relative)
        const tryFetch = async () => {
          try {
            // Use cache: 'no-store' to always get fresh changelog data
            const fetchOptions = { cache: 'no-store' };

            // Try production path first
            let response = await fetch('/rosterrank/changelog.json', fetchOptions);

            if (!response.ok) {
              // Fallback to relative path for local development
              response = await fetch('./changelog.json', fetchOptions);
            }

            // Parse JSON regardless of content-type (GitHub Pages may not set it correctly)
            const data = await response.json();
            setAppVersion(data.version);
            setChangelog(data.releases);

            // Check if user has seen this version (only after successful load)
            const lastSeenVersion = localStorage.getItem('lastSeenVersion');
            if (lastSeenVersion !== data.version) {
              // Don't auto-show on first visit, only on updates
              if (lastSeenVersion !== null) {
                setUpdateModal(true);
              }
              localStorage.setItem('lastSeenVersion', data.version);
            }
          } catch (error) {
            console.error('Error loading changelog:', error);
            // Fallback to default version if all fetch attempts fail
            setAppVersion('1.0.0');
            setChangelog({});
          }
        };

        tryFetch();
      }, []);

      // Make setUpdateModal available globally for service worker
      useEffect(() => {
        window.showUpdateModal = async () => {
          // Re-fetch changelog to get the latest version info
          try {
            const fetchOptions = { cache: 'no-store' };
            let response = await fetch('/rosterrank/changelog.json', fetchOptions);
            if (!response.ok) {
              response = await fetch('./changelog.json', fetchOptions);
            }
            const data = await response.json();
            setAppVersion(data.version);
            setChangelog(data.releases);
            localStorage.setItem('lastSeenVersion', data.version);
          } catch (error) {
            console.error('Error refreshing changelog:', error);
          }
          setUpdateModal(true);
        };
        return () => delete window.showUpdateModal;
      }, []);

      // Cleanup undo timeout on unmount
      useEffect(() => {
        return () => {
          if (undoTimeoutRef.current) {
            clearTimeout(undoTimeoutRef.current);
          }
        };
      }, []);

      const currentChangelog = changelog[appVersion] || { date: '', changes: [] };

      // Anonymous authentication
      useEffect(() => {
        const unsubscribe = auth.onAuthStateChanged(async (user) => {
          if (user) {
            setUserId(user.uid);
            // Save user ID to localStorage as backup
            const savedUserId = localStorage.getItem('rosterRankUserId');
            if (!savedUserId) {
              localStorage.setItem('rosterRankUserId', user.uid);
            } else if (savedUserId !== user.uid) {
              // User ID changed! This means auth was reset.
              // Log this for debugging and save the new one
              console.warn('User ID changed from', savedUserId, 'to', user.uid);
              console.warn('Old data may be at:', savedUserId);
              localStorage.setItem('rosterRankPreviousUserId', savedUserId);
              localStorage.setItem('rosterRankUserId', user.uid);
            }
          } else {
            // Sign in anonymously
            try {
              await auth.signInAnonymously();
            } catch (error) {
              console.error('Auth error:', error);
              setSyncStatus('error');
              // Fall back to localStorage
              const saved = localStorage.getItem('softballPlayers');
              if (saved) {
                try {
                  setPlayers(JSON.parse(saved));
                } catch (e) {
                  console.error('Error loading saved data:', e);
                }
              }
              setIsLoading(false);
            }
          }
        });
        return () => unsubscribe();
      }, []);

      // Firestore real-time sync
      useEffect(() => {
        if (!userId) return;

        setSyncStatus('syncing');

        // Set up real-time listener
        const unsubscribe = db.collection('users').doc(userId).collection('players')
          .orderBy('totalScore', 'desc')
          .onSnapshot(
            (snapshot) => {
              const firestorePlayers = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
              }));

              // If Firestore is empty but localStorage has data, migrate it (only once per session)
              if (firestorePlayers.length === 0 && !hasMigratedRef.current) {
                // Check if user previously had data synced (indicates intentional deletion vs first time)
                const hadSyncedBefore = localStorage.getItem('rosterRankHasSynced') === 'true';

                if (!hadSyncedBefore) {
                  // First time user or fresh install - try to migrate existing localStorage data
                  const saved = localStorage.getItem('softballPlayers') || localStorage.getItem('softballPlayersBackup');
                  if (saved) {
                    try {
                      const localPlayers = JSON.parse(saved);
                      if (localPlayers.length > 0) {
                        // Migrate localStorage data to Firestore
                        const batch = db.batch();
                        localPlayers.forEach(player => {
                          const docRef = db.collection('users').doc(userId).collection('players').doc(String(player.id));
                          batch.set(docRef, player);
                        });
                        batch.commit().then(() => {
                          console.log('Migrated localStorage data to Firestore');
                          localStorage.setItem('rosterRankHasSynced', 'true');
                        });
                        setPlayers(localPlayers);
                      }
                    } catch (e) {
                      console.error('Error migrating data:', e);
                    }
                  }
                } else {
                  // User had synced before but Firestore is empty - they deleted all players
                  setPlayers([]);
                  // Clear localStorage to prevent unwanted restoration and confusing "restore" button
                  localStorage.setItem('softballPlayers', JSON.stringify([]));
                  localStorage.removeItem('softballPlayersBackup');
                }
                hasMigratedRef.current = true;
              } else if (firestorePlayers.length === 0) {
                // Firestore is empty and we've already checked migration this session
                setPlayers([]);
              } else {
                setPlayers(firestorePlayers);
                // Keep localStorage in sync for offline fallback
                localStorage.setItem('softballPlayers', JSON.stringify(firestorePlayers));
                // Also save a backup copy for recovery
                localStorage.setItem('softballPlayersBackup', JSON.stringify(firestorePlayers));
                // Mark that user has successfully synced (to distinguish from first-time users)
                localStorage.setItem('rosterRankHasSynced', 'true');
                hasMigratedRef.current = true;
              }

              setSyncStatus('synced');
              setIsLoading(false);
            },
            (error) => {
              console.error('Firestore sync error:', error);
              setSyncStatus('error');
              // Fall back to localStorage
              const saved = localStorage.getItem('softballPlayers');
              if (saved) {
                try {
                  setPlayers(JSON.parse(saved));
                } catch (e) {
                  console.error('Error loading saved data:', e);
                }
              }
              setIsLoading(false);
            }
          );

        return () => unsubscribe();
      }, [userId]);

      useEffect(() => {
        const onKey = (e) => {
          if (e.key === 'Escape') {
            if (modal.visible) setModal({ visible: false, title: '', message: '', onAction: null, actionLabel: '', isImportHelp: false });
            if (updateModal) setUpdateModal(false);
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [modal.visible, updateModal]);

      const addPlayer = async () => {
        if (currentPlayer.number.trim()) {
          const totalScore = currentPlayer.hitting + currentPlayer.popfly + currentPlayer.fielding + currentPlayer.throwing;
          // Prevent duplicate player numbers
          const numberToAdd = currentPlayer.number.trim();
          const existingPlayer = players.find(p => String(p.number).trim() === numberToAdd);
          if (existingPlayer) {
            setModal({
              visible: true,
              title: 'Duplicate Number',
              message: `Player #${numberToAdd} already exists. Would you like to edit the existing player instead?`,
              onAction: () => {
                startEdit(existingPlayer);
                setModal({ visible: false, title: '', message: '', onAction: null, actionLabel: '', isImportHelp: false });
              },
              actionLabel: 'Edit Existing Player'
            });
            return;
          }

          const newPlayer = { ...currentPlayer, id: Date.now(), totalScore };

          // Save to Firestore if authenticated
          if (userId) {
            setSyncStatus('syncing');
            try {
              await db.collection('users').doc(userId).collection('players').doc(String(newPlayer.id)).set(newPlayer);
              setSyncStatus('synced');
            } catch (error) {
              console.error('Error saving player:', error);
              setSyncStatus('error');
              // Still add to local state as fallback
              setPlayers([...players, newPlayer]);
              localStorage.setItem('softballPlayers', JSON.stringify([...players, newPlayer]));
            }
          } else {
            // Offline fallback
            setPlayers([...players, newPlayer]);
            localStorage.setItem('softballPlayers', JSON.stringify([...players, newPlayer]));
          }

          setCurrentPlayer({
            number: '',
            hitting: 5,
            popfly: 5,
            fielding: 5,
            throwing: 5,
            comments: '',
            starred: false
          });
        }
      };

      const startEdit = (player) => {
        setEditingId(player.id);
        setCurrentPlayer({ ...player });
        // Scroll to form
        window.scrollTo({ top: 0, behavior: 'smooth' });
      };

      const saveEdit = async () => {
        const totalScore = currentPlayer.hitting + currentPlayer.popfly + currentPlayer.fielding + currentPlayer.throwing;
        // Prevent duplicate player numbers when saving edits
        const editedNumber = String(currentPlayer.number || '').trim();
        if (!editedNumber) {
          setModal({ visible: true, title: 'Missing Number', message: 'Player number is required.', onAction: null, actionLabel: '' });
          return;
        }

        const existingPlayer = players.find(p => p.id !== editingId && String(p.number).trim() === editedNumber);
        if (existingPlayer) {
          setModal({
            visible: true,
            title: 'Duplicate Number',
            message: `Player #${editedNumber} already exists. Would you like to switch to editing that player instead?`,
            onAction: () => {
              startEdit(existingPlayer);
              setModal({ visible: false, title: '', message: '', onAction: null, actionLabel: '', isImportHelp: false });
            },
            actionLabel: 'Switch to That Player'
          });
          return;
        }

        const updatedPlayer = { ...currentPlayer, totalScore };

        // Save to Firestore if authenticated
        if (userId) {
          setSyncStatus('syncing');
          try {
            await db.collection('users').doc(userId).collection('players').doc(String(editingId)).set(updatedPlayer);
            setSyncStatus('synced');
          } catch (error) {
            console.error('Error updating player:', error);
            setSyncStatus('error');
            // Still update local state as fallback
            const updatedPlayers = players.map(p => p.id === editingId ? updatedPlayer : p);
            setPlayers(updatedPlayers);
            localStorage.setItem('softballPlayers', JSON.stringify(updatedPlayers));
          }
        } else {
          // Offline fallback
          const updatedPlayers = players.map(p => p.id === editingId ? updatedPlayer : p);
          setPlayers(updatedPlayers);
          localStorage.setItem('softballPlayers', JSON.stringify(updatedPlayers));
        }

        cancelEdit();
      };

      const cancelEdit = () => {
        setEditingId(null);
        setCurrentPlayer({
          number: '',
          hitting: 5,
          popfly: 5,
          fielding: 5,
          throwing: 5,
          comments: '',
          starred: false
        });
      };

      const deletePlayer = async (id) => {
        // Store the player for undo before deleting
        const playerToDelete = players.find(p => p.id === id);
        if (playerToDelete) {
          // Clear any existing undo timeout
          if (undoTimeoutRef.current) {
            clearTimeout(undoTimeoutRef.current);
          }
          setDeletedPlayer(playerToDelete);
          // Auto-dismiss after 5 seconds
          undoTimeoutRef.current = setTimeout(() => {
            setDeletedPlayer(null);
          }, 5000);
        }

        // Delete from Firestore if authenticated
        if (userId) {
          setSyncStatus('syncing');
          try {
            await db.collection('users').doc(userId).collection('players').doc(String(id)).delete();
            setSyncStatus('synced');
          } catch (error) {
            console.error('Error deleting player:', error);
            setSyncStatus('error');
            // Still delete from local state as fallback
            const remainingPlayers = players.filter(p => p.id !== id);
            setPlayers(remainingPlayers);
            // Keep localStorage for recovery even if empty
            localStorage.setItem('softballPlayers', JSON.stringify(remainingPlayers));
          }
        } else {
          // Offline fallback
          const remainingPlayers = players.filter(p => p.id !== id);
          setPlayers(remainingPlayers);
          // Keep localStorage for recovery even if empty
          localStorage.setItem('softballPlayers', JSON.stringify(remainingPlayers));
        }
      };

      const showImportHelp = () => {
        setModal({
          visible: true,
          title: 'Import CSV',
          message: '',
          onAction: () => {
            // Click file input first (while still in user gesture context), then close modal
            fileInputRef.current?.click();
            setModal({ visible: false, title: '', message: '', onAction: null, actionLabel: '', isImportHelp: false });
          },
          actionLabel: 'Select File',
          isImportHelp: true
        });
      };

      const toggleStar = async (id) => {
        const player = players.find(p => p.id === id);
        if (!player) return;

        const updatedPlayer = { ...player, starred: !player.starred };

        if (userId) {
          setSyncStatus('syncing');
          try {
            await db.collection('users').doc(userId).collection('players').doc(String(id)).set(updatedPlayer);
            setSyncStatus('synced');
          } catch (error) {
            console.error('Error toggling star:', error);
            setSyncStatus('error');
            const updatedPlayers = players.map(p => p.id === id ? updatedPlayer : p);
            setPlayers(updatedPlayers);
            localStorage.setItem('softballPlayers', JSON.stringify(updatedPlayers));
          }
        } else {
          const updatedPlayers = players.map(p => p.id === id ? updatedPlayer : p);
          setPlayers(updatedPlayers);
          localStorage.setItem('softballPlayers', JSON.stringify(updatedPlayers));
        }
      };

      const undoDelete = async () => {
        if (!deletedPlayer) return;

        // Clear the timeout
        if (undoTimeoutRef.current) {
          clearTimeout(undoTimeoutRef.current);
        }

        const playerToRestore = deletedPlayer;
        setDeletedPlayer(null);

        // Restore to Firestore if authenticated
        if (userId) {
          setSyncStatus('syncing');
          try {
            await db.collection('users').doc(userId).collection('players').doc(String(playerToRestore.id)).set(playerToRestore);
            setSyncStatus('synced');
          } catch (error) {
            console.error('Error restoring player:', error);
            setSyncStatus('error');
            // Still restore to local state as fallback
            const updatedPlayers = [...players, playerToRestore].sort((a, b) => {
              if (a.starred && !b.starred) return -1;
              if (!a.starred && b.starred) return 1;
              return b.totalScore - a.totalScore;
            });
            setPlayers(updatedPlayers);
            localStorage.setItem('softballPlayers', JSON.stringify(updatedPlayers));
          }
        } else {
          // Offline fallback
          const updatedPlayers = [...players, playerToRestore].sort((a, b) => {
            if (a.starred && !b.starred) return -1;
            if (!a.starred && b.starred) return 1;
            return b.totalScore - a.totalScore;
          });
          setPlayers(updatedPlayers);
          localStorage.setItem('softballPlayers', JSON.stringify(updatedPlayers));
        }
      };

      const exportData = () => {
        if (players.length === 0) {
          alert('No players to export!');
          return;
        }

        const headers = ['Player Number', 'Starred', 'Hitting', 'Pop Fly', 'Fielding', 'Throwing', 'Total Score', 'Comments'];

        const rows = players.map(player => [
          player.number,
          player.starred ? 'Yes' : 'No',
          player.hitting,
          player.popfly || player.bunting || 0,
          player.fielding,
          player.throwing,
          player.totalScore,
          `"${(player.comments || '').replace(/"/g, '""')}"`
        ]);
        
        const csvContent = [
          headers.join(','),
          ...rows.map(row => row.join(','))
        ].join('\n');
        
        const dataBlob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'softball-ratings.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      };

      const importData = async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const text = e.target.result;
            const lines = text.split('\n').filter(line => line.trim());

            if (lines.length < 2) {
              setModal({ visible: true, title: 'Invalid File', message: 'CSV file is empty or invalid.', onAction: null, actionLabel: '' });
              return;
            }

            // Parse header to find column indices
            const header = lines[0].split(',').map(h => h.trim().toLowerCase());
            const playerNumIdx = header.findIndex(h => h.includes('player') && h.includes('number'));
            const starredIdx = header.findIndex(h => h.includes('starred'));
            const hittingIdx = header.findIndex(h => h.includes('hitting') || h === 'hit');
            const popflyIdx = header.findIndex(h => h.includes('pop') || h.includes('fly'));
            const fieldingIdx = header.findIndex(h => h.includes('fielding') || h === 'fld');
            const throwingIdx = header.findIndex(h => h.includes('throwing') || h === 'arm');
            const commentsIdx = header.findIndex(h => h.includes('comment'));

            if (playerNumIdx === -1) {
              setModal({ visible: true, title: 'Invalid Format', message: 'Could not find Player Number column in CSV.', onAction: null, actionLabel: '' });
              return;
            }

            const newPlayers = [];
            const existingNumbers = new Set(players.map(p => String(p.number).trim()));
            let skipped = 0;

            for (let i = 1; i < lines.length; i++) {
              // Parse CSV line (handle quoted fields with commas)
              const row = [];
              let current = '';
              let inQuotes = false;
              for (const char of lines[i]) {
                if (char === '"') {
                  inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                  row.push(current.trim());
                  current = '';
                } else {
                  current += char;
                }
              }
              row.push(current.trim());

              const playerNum = row[playerNumIdx]?.trim();
              if (!playerNum) continue;

              // Skip if player number already exists
              if (existingNumbers.has(playerNum)) {
                skipped++;
                continue;
              }

              const starred = starredIdx >= 0 && row[starredIdx]?.toLowerCase() === 'yes';
              const hitting = hittingIdx >= 0 ? parseInt(row[hittingIdx]) || 5 : 5;
              const popfly = popflyIdx >= 0 ? parseInt(row[popflyIdx]) || 5 : 5;
              const fielding = fieldingIdx >= 0 ? parseInt(row[fieldingIdx]) || 5 : 5;
              const throwing = throwingIdx >= 0 ? parseInt(row[throwingIdx]) || 5 : 5;
              const comments = commentsIdx >= 0 ? row[commentsIdx]?.replace(/^"|"$/g, '') || '' : '';
              const totalScore = hitting + popfly + fielding + throwing;

              newPlayers.push({
                id: Date.now() + i,
                number: playerNum,
                starred,
                hitting: Math.min(10, Math.max(1, hitting)),
                popfly: Math.min(10, Math.max(1, popfly)),
                fielding: Math.min(10, Math.max(1, fielding)),
                throwing: Math.min(10, Math.max(1, throwing)),
                totalScore,
                comments
              });

              existingNumbers.add(playerNum);
            }

            if (newPlayers.length === 0) {
              setModal({
                visible: true,
                title: 'No Players Imported',
                message: skipped > 0
                  ? `No new players to import. ${skipped} player(s) skipped because they already exist.`
                  : 'No valid players found in CSV file.',
                onAction: null,
                actionLabel: ''
              });
              return;
            }

            // Save to Firestore if authenticated
            if (userId) {
              setSyncStatus('syncing');
              try {
                const batch = db.batch();
                newPlayers.forEach(player => {
                  const docRef = db.collection('users').doc(userId).collection('players').doc(String(player.id));
                  batch.set(docRef, player);
                });
                await batch.commit();
                setSyncStatus('synced');
              } catch (error) {
                console.error('Error importing players:', error);
                setSyncStatus('error');
                // Still add to local state as fallback
                const allPlayers = [...players, ...newPlayers];
                setPlayers(allPlayers);
                localStorage.setItem('softballPlayers', JSON.stringify(allPlayers));
              }
            } else {
              // Offline fallback
              const allPlayers = [...players, ...newPlayers];
              setPlayers(allPlayers);
              localStorage.setItem('softballPlayers', JSON.stringify(allPlayers));
            }

            setModal({
              visible: true,
              title: 'Import Successful',
              message: `Imported ${newPlayers.length} player(s)${skipped > 0 ? `. ${skipped} skipped (already exist).` : '.'}`,
              onAction: null,
              actionLabel: ''
            });

          } catch (error) {
            console.error('Error parsing CSV:', error);
            setModal({ visible: true, title: 'Import Error', message: 'Error parsing CSV file. Please check the format.', onAction: null, actionLabel: '' });
          }
        };

        reader.readAsText(file);
        // Reset file input so same file can be imported again
        event.target.value = '';
      };

      const getScoreColor = (score) => {
        if (score >= 32) return 'bg-amber-500 text-slate-900';
        if (score >= 24) return 'bg-emerald-600 text-white';
        if (score >= 16) return 'bg-blue-600 text-white';
        return 'bg-slate-600 text-white';
      };

      const getHighestCategoryColor = (player) => {
        const categories = [
          { key: 'hitting', value: player.hitting, color: 'bg-red-600 text-white' },
          { key: 'popfly', value: player.popfly || 0, color: 'bg-blue-600 text-white' },
          { key: 'fielding', value: player.fielding, color: 'bg-emerald-600 text-white' },
          { key: 'throwing', value: player.throwing, color: 'bg-purple-600 text-white' }
        ];
        const highest = categories.reduce((max, cat) => cat.value > max.value ? cat : max, categories[0]);
        return highest.color;
      };

      const getSliderStyle = (value, color) => {
        return {
          background: `linear-gradient(to right, ${color} 0%, ${color} ${value * 10}%, #334155 ${value * 10}%, #334155 100%)`,
          color: color
        };
      };

      const getSyncStatusDisplay = () => {
        switch (syncStatus) {
          case 'synced':
            return { icon: <Cloud size={14} />, text: 'Synced', color: 'text-green-300' };
          case 'syncing':
            return { icon: <Loader size={14} className="animate-spin" />, text: 'Syncing...', color: 'text-yellow-300' };
          case 'error':
            return { icon: <CloudOff size={14} />, text: 'Sync error', color: 'text-red-300' };
          default:
            return { icon: <CloudOff size={14} />, text: 'Offline', color: 'text-gray-300' };
        }
      };

      const syncDisplay = getSyncStatusDisplay();

      // Show loading screen while initializing
      if (isLoading) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center safe-area-top" style={{fontFamily: 'system-ui, -apple-system, sans-serif'}}>
            <div className="text-center">
              <div className="text-3xl font-black text-white mb-4">ROSTER<span className="text-amber-500">RANK</span></div>
              <Loader size={24} className="animate-spin text-amber-500 mx-auto" />
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 px-2 py-3 sm:p-6 safe-area-top safe-area-bottom overflow-x-hidden" style={{fontFamily: 'system-ui, -apple-system, sans-serif'}}>
          {/* Hidden file input - always rendered so ref is available */}
          <input
            type="file"
            ref={fileInputRef}
            accept=".csv"
            onChange={importData}
            className="hidden"
          />
          <div className="max-w-2xl mx-auto w-full">
            {/* Header */}
            <div className="relative text-center mb-3 sm:mb-4">
              {/* Sync Status - top right */}
              <button
                onClick={() => {
                  const previousId = localStorage.getItem('rosterRankPreviousUserId');
                  let message = `Account ID:\n${userId || 'Not connected'}\n\n`;
                  if (previousId) {
                    message += `⚠️ Previous ID detected:\n${previousId}\n\nYour data may still exist under the old ID in Firebase.`;
                  }
                  alert(message);
                }}
                className={`absolute top-0 right-0 inline-flex items-center gap-1 text-xs ${syncDisplay.color} hover:opacity-80 transition`}
              >
                {syncDisplay.icon}
                <span>{syncDisplay.text}</span>
              </button>
              <h1 className="text-2xl sm:text-4xl font-black text-white mb-0.5 sm:mb-1 tracking-tight">
                ROSTER<span className="text-amber-500">RANK</span>
              </h1>
              <p className="text-slate-400 font-medium text-xs sm:text-sm uppercase tracking-widest">Player Analytics</p>
            </div>

            {/* Form */}
            <div className="bg-slate-800 rounded-xl shadow-2xl p-3 sm:p-4 mb-3 sm:mb-4 border border-slate-700">
              <div className="flex items-center gap-2 mb-3">
                <button
                  type="button"
                  onClick={() => setCurrentPlayer({...currentPlayer, starred: !currentPlayer.starred})}
                  className={`p-2.5 sm:p-3 rounded-lg border-2 transition active:scale-90 flex-shrink-0 ${
                    currentPlayer.starred
                      ? 'bg-amber-500/20 border-amber-500 text-amber-500'
                      : 'bg-slate-900 border-slate-600 text-slate-500 hover:border-amber-500 hover:text-amber-500'
                  }`}
                  title={currentPlayer.starred ? 'Remove from favorites' : 'Add to favorites'}
                >
                  <Star size={22} filled={currentPlayer.starred} />
                </button>
                <input
                  type="text"
                  inputMode="numeric"
                  pattern="[0-9]*"
                  value={currentPlayer.number}
                  onChange={(e) => setCurrentPlayer({...currentPlayer, number: e.target.value.replace(/[^0-9]/g, '')})}
                  className="flex-1 min-w-0 px-3 sm:px-4 py-2.5 sm:py-3 text-xl sm:text-2xl font-bold text-center bg-slate-900 border-2 border-slate-600 rounded-lg focus:outline-none focus:border-amber-500 text-white placeholder-slate-500"
                  placeholder="# Player Number"
                />
              </div>

              {/* Compact Sliders */}
              <div className="space-y-2.5 sm:space-y-3 mb-3">
                {[
                  {key: 'hitting', label: 'HIT', color: '#dc2626'},
                  {key: 'popfly', label: 'FLY', color: '#2563eb'},
                  {key: 'fielding', label: 'FLD', color: '#059669'},
                  {key: 'throwing', label: 'ARM', color: '#7c3aed'}
                ].map(({key, label, color}) => (
                  <div key={key} className="flex items-center gap-2 sm:gap-3">
                    <div className="w-10 sm:w-12 text-xs font-bold text-slate-500 uppercase tracking-wide">
                      {label}
                    </div>
                    <input
                      type="range"
                      min="1"
                      max="10"
                      value={currentPlayer[key]}
                      onChange={(e) => setCurrentPlayer({...currentPlayer, [key]: parseInt(e.target.value)})}
                      className="flex-1 h-3 rounded-lg cursor-pointer"
                      style={getSliderStyle(currentPlayer[key], color)}
                    />
                    <div className="w-9 sm:w-10 h-7 sm:h-8 text-white font-bold text-base sm:text-lg rounded flex items-center justify-center flex-shrink-0" style={{backgroundColor: color}}>
                      {currentPlayer[key]}
                    </div>
                  </div>
                ))}
              </div>

              <textarea
                value={currentPlayer.comments}
                onChange={(e) => setCurrentPlayer({...currentPlayer, comments: e.target.value})}
                className="w-full px-3 py-2 mb-3 bg-slate-900 border border-slate-600 rounded-lg focus:outline-none focus:border-amber-500 text-sm text-slate-300 placeholder-slate-500"
                rows="2"
                placeholder="Notes..."
              />

              {editingId ? (
                <div className="flex gap-2">
                  <button
                    onClick={saveEdit}
                    className="flex-1 bg-amber-500 hover:bg-amber-600 text-slate-900 font-bold py-3 rounded-lg active:scale-95 transition"
                  >
                    <Save className="inline mr-1" size={18} />
                    SAVE
                  </button>
                  <button
                    onClick={cancelEdit}
                    className="flex-1 bg-slate-600 hover:bg-slate-500 text-white font-bold py-3 rounded-lg active:scale-95 transition"
                  >
                    <X className="inline mr-1" size={18} />
                    CANCEL
                  </button>
                </div>
              ) : (
                <button
                  onClick={addPlayer}
                  className="w-full bg-amber-500 hover:bg-amber-600 text-slate-900 font-bold py-3 rounded-lg active:scale-95 transition"
                >
                  <Plus className="inline mr-2" size={20} />
                  ADD PLAYER
                </button>
              )}
            </div>

            {/* Roster */}
            {players.length > 0 && (
              <div className="bg-slate-800 rounded-xl shadow-2xl p-3 sm:p-4 border border-slate-700">
                <div className="flex justify-between items-center mb-3">
                  <h2 className="text-base sm:text-lg font-bold text-white">
                    <span className="text-amber-500">{players.length}</span> {players.length === 1 ? 'Player' : 'Players'}
                  </h2>
                  <div className="flex gap-1.5 sm:gap-2">
                    <button
                      onClick={showImportHelp}
                      className="bg-slate-700 hover:bg-slate-600 text-slate-300 px-2.5 sm:px-3 py-1.5 rounded text-xs sm:text-sm font-medium active:scale-95 transition"
                    >
                      <Upload className="inline mr-1" size={14} />
                      Import
                    </button>
                    <button
                      onClick={exportData}
                      className="bg-slate-700 hover:bg-slate-600 text-slate-300 px-2.5 sm:px-3 py-1.5 rounded text-xs sm:text-sm font-medium active:scale-95 transition"
                    >
                      <Download className="inline mr-1" size={14} />
                      Export
                    </button>
                  </div>
                </div>

                <div className="space-y-2">
                  {players.sort((a, b) => {
                    // Starred players first
                    if (a.starred && !b.starred) return -1;
                    if (!a.starred && b.starred) return 1;
                    // Then by score
                    return b.totalScore - a.totalScore;
                  }).map((player, index) => (
                    <div key={player.id} className="border border-slate-600 rounded-lg p-2.5 sm:p-3 bg-slate-900">
                      <div className="flex items-center justify-between mb-2 gap-1">
                        <div className="flex items-center gap-1.5 sm:gap-2 min-w-0">
                          <button
                            onClick={() => toggleStar(player.id)}
                            className={`active:scale-90 transition flex-shrink-0 p-1 -m-1 ${
                              player.starred ? 'text-amber-500' : 'text-slate-600 hover:text-amber-500'
                            }`}
                            title={player.starred ? 'Remove from favorites' : 'Add to favorites'}
                          >
                            <Star size={18} filled={player.starred} />
                          </button>
                          <div className="w-6 h-6 sm:w-7 sm:h-7 bg-amber-500 text-slate-900 font-bold rounded-full flex items-center justify-center text-xs sm:text-sm flex-shrink-0">
                            {index + 1}
                          </div>
                          <div className="text-lg sm:text-xl font-bold text-white truncate">
                            #{player.number}
                          </div>
                        </div>
                        <div className="flex items-center gap-1.5 sm:gap-2 flex-shrink-0">
                          <div className={`${getHighestCategoryColor(player)} px-2 sm:px-3 py-0.5 sm:py-1 rounded font-bold text-base sm:text-lg`}>
                            {player.totalScore}
                          </div>
                          <button
                            onClick={() => startEdit(player)}
                            className="text-slate-400 hover:text-amber-500 active:scale-90 transition p-1.5 -m-1"
                          >
                            <Edit2 size={18} />
                          </button>
                          <button
                            onClick={() => deletePlayer(player.id)}
                            className="text-slate-400 hover:text-red-500 active:scale-90 transition p-1.5 -m-1"
                          >
                            <Trash2 size={18} />
                          </button>
                        </div>
                      </div>

                      <div className="grid grid-cols-4 gap-1 text-xs font-medium">
                        <div className="bg-red-900/30 text-red-400 rounded px-1.5 sm:px-2 py-1 text-center">HIT {player.hitting}</div>
                        <div className="bg-blue-900/30 text-blue-400 rounded px-1.5 sm:px-2 py-1 text-center">FLY {player.popfly}</div>
                        <div className="bg-emerald-900/30 text-emerald-400 rounded px-1.5 sm:px-2 py-1 text-center">FLD {player.fielding}</div>
                        <div className="bg-purple-900/30 text-purple-400 rounded px-1.5 sm:px-2 py-1 text-center">ARM {player.throwing}</div>
                      </div>

                      {player.comments && (
                        <div className="mt-2 text-xs text-slate-400 italic bg-slate-800 rounded p-2 border border-slate-700">
                          {player.comments}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {players.length === 0 && (
              <div className="bg-slate-800 rounded-xl shadow-2xl p-8 text-center border border-slate-700">
                <div className="text-5xl mb-3 opacity-50">👤</div>
                <p className="text-slate-400 font-bold text-lg">Add your first player</p>
                <p className="text-slate-500 text-sm mt-2">or import from a CSV file</p>
                <button
                  onClick={showImportHelp}
                  className="mt-3 bg-slate-700 hover:bg-slate-600 text-slate-300 font-medium px-4 py-2 rounded-lg text-sm active:scale-95 transition"
                >
                  <Upload size={14} className="inline mr-1" />
                  Import CSV
                </button>
                {/* Recovery option if backup exists */}
                {(() => {
                  const backup = localStorage.getItem('softballPlayersBackup');
                  const main = localStorage.getItem('softballPlayers');
                  const hasBackup = backup && JSON.parse(backup).length > 0;
                  const hasMain = main && JSON.parse(main).length > 0;
                  if (hasBackup || hasMain) {
                    const data = hasMain ? JSON.parse(main) : JSON.parse(backup);
                    return (
                      <button
                        onClick={async () => {
                          if (userId) {
                            setSyncStatus('syncing');
                            try {
                              const batch = db.batch();
                              data.forEach(player => {
                                const docRef = db.collection('users').doc(userId).collection('players').doc(String(player.id));
                                batch.set(docRef, player);
                              });
                              await batch.commit();
                              setSyncStatus('synced');
                            } catch (error) {
                              console.error('Error restoring backup:', error);
                              setSyncStatus('error');
                              setPlayers(data);
                            }
                          } else {
                            setPlayers(data);
                          }
                        }}
                        className="mt-4 bg-amber-500 hover:bg-amber-600 text-slate-900 font-bold px-4 py-2 rounded-lg text-sm active:scale-95 transition"
                      >
                        <Undo size={14} className="inline mr-1" />
                        Restore {data.length} player{data.length !== 1 ? 's' : ''} from backup
                      </button>
                    );
                  }
                  return null;
                })()}
              </div>
            )}

            {/* Version Footer */}
            {appVersion && (
              <div className="text-center mt-4 mb-2">
                <button
                  onClick={() => setUpdateModal(true)}
                  className="text-white/70 hover:text-white text-xs font-bold transition"
                >
                  v{appVersion} - What's New?
                </button>
              </div>
            )}
          </div>

          {modal.visible && (
            <div
              className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 animate-fadeIn"
              style={{animation: 'fadeIn 0.2s ease-out'}}
              onClick={() => setModal({ visible: false, title: '', message: '', onAction: null, actionLabel: '', isImportHelp: false })}
            >
              <style>{`
                @keyframes fadeIn {
                  from { opacity: 0; }
                  to { opacity: 1; }
                }
                @keyframes slideUp {
                  from {
                    opacity: 0;
                    transform: translateY(20px) scale(0.95);
                  }
                  to {
                    opacity: 1;
                    transform: translateY(0) scale(1);
                  }
                }
                @keyframes pulse {
                  0%, 100% { transform: scale(1); }
                  50% { transform: scale(1.05); }
                }
                @keyframes spin {
                  from { transform: rotate(0deg); }
                  to { transform: rotate(360deg); }
                }
              `}</style>
              <div
                className="bg-slate-800 rounded-xl p-6 max-w-sm w-full mx-4 shadow-2xl text-center border border-slate-700"
                style={{animation: 'slideUp 0.3s ease-out'}}
                onClick={(e) => e.stopPropagation()}
                role="dialog"
                aria-modal="true"
                aria-labelledby="modal-title"
              >
                <div className="mb-4">
                  <div
                    className={`w-16 h-16 mx-auto rounded-full flex items-center justify-center ${
                      modal.isImportHelp
                        ? 'bg-blue-500'
                        : modal.onAction
                          ? 'bg-amber-500'
                          : modal.title?.toLowerCase().includes('success')
                            ? 'bg-emerald-500'
                            : 'bg-red-500'
                    }`}
                  >
                    {modal.isImportHelp ? (
                      <Upload size={32} className="text-white" strokeWidth={2.5} />
                    ) : modal.onAction ? (
                      <Edit2 size={32} className="text-slate-900" strokeWidth={2.5} />
                    ) : modal.title?.toLowerCase().includes('success') ? (
                      <CheckCircle size={32} className="text-white" strokeWidth={2.5} />
                    ) : (
                      <AlertCircle size={32} className="text-white" strokeWidth={2.5} />
                    )}
                  </div>
                </div>
                <div id="modal-title" className="text-xl font-bold text-white mb-2">{modal.title}</div>
                {modal.isImportHelp ? (
                  <div className="text-left mb-5">
                    <div className="bg-slate-900 rounded-lg p-3 border border-slate-700 text-sm">
                      <div className="text-slate-300 mb-3">
                        <span className="text-amber-500 font-bold">Required:</span>
                        <div className="text-slate-400 ml-2 mt-1">• Player Number</div>
                      </div>
                      <div className="text-slate-300 mb-3">
                        <span className="text-blue-400 font-bold">Optional:</span>
                        <div className="text-slate-400 ml-2 mt-1 space-y-0.5">
                          <div>• Starred (Yes/No)</div>
                          <div>• Hitting, Pop Fly, Fielding, Throwing (1-10)</div>
                          <div>• Comments</div>
                        </div>
                      </div>
                      <div className="text-slate-500 text-xs border-t border-slate-700 pt-2 mt-2">
                        <div>• Missing scores default to 5</div>
                        <div>• Duplicate player numbers are skipped</div>
                        <div>• Use exported CSV as a template</div>
                      </div>
                    </div>
                  </div>
                ) : (
                  <div className="text-sm text-slate-400 mb-6 leading-relaxed">{modal.message}</div>
                )}
                {modal.onAction ? (
                  <div className="space-y-2">
                    <button
                      onClick={modal.onAction}
                      className={`w-full font-bold py-3 rounded-lg active:scale-95 transition ${
                        modal.isImportHelp
                          ? 'bg-blue-500 hover:bg-blue-600 text-white'
                          : 'bg-amber-500 hover:bg-amber-600 text-slate-900'
                      }`}
                    >
                      {modal.isImportHelp ? (
                        <Upload className="inline mr-2" size={18} />
                      ) : (
                        <Edit2 className="inline mr-2" size={18} />
                      )}
                      {modal.actionLabel}
                    </button>
                    <button
                      onClick={() => setModal({ visible: false, title: '', message: '', onAction: null, actionLabel: '', isImportHelp: false })}
                      className="w-full bg-slate-700 hover:bg-slate-600 text-slate-300 font-bold py-3 rounded-lg active:scale-95 transition"
                    >
                      <X className="inline mr-1" size={16} />
                      Cancel
                    </button>
                  </div>
                ) : (
                  <button
                    onClick={() => setModal({ visible: false, title: '', message: '', onAction: null, actionLabel: '', isImportHelp: false })}
                    className="w-full bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 rounded-lg active:scale-95 transition"
                  >
                    OK
                  </button>
                )}
              </div>
            </div>
          )}

          {updateModal && (
            <div
              className="fixed inset-0 bg-black/70 flex items-center justify-center z-50"
              style={{animation: 'fadeIn 0.2s ease-out'}}
              onClick={() => setUpdateModal(false)}
            >
              <div
                className="bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl text-center border border-slate-700"
                style={{animation: 'slideUp 0.3s ease-out'}}
                onClick={(e) => e.stopPropagation()}
                role="dialog"
                aria-modal="true"
              >
                <div className="mb-4">
                  <div className="w-16 h-16 mx-auto bg-amber-500 rounded-full flex items-center justify-center">
                    <Sparkles size={32} className="text-slate-900" strokeWidth={2.5} />
                  </div>
                </div>
                <div className="text-xl font-bold text-white mb-1">What's New</div>
                <div className="text-amber-500 font-bold mb-1">v{appVersion}</div>
                {currentChangelog.date && (
                  <div className="text-xs text-slate-500 mb-4">{currentChangelog.date}</div>
                )}
                <div className="bg-slate-900 rounded-lg p-4 mb-5 text-left border border-slate-700">
                  <ul className="text-sm text-slate-300 space-y-2">
                    {currentChangelog.changes.map((change, index) => (
                      <li key={index} className="flex items-start gap-2">
                        <span className="text-amber-500 font-bold">•</span>
                        <span>{change}</span>
                      </li>
                    ))}
                  </ul>
                </div>
                <button
                  onClick={() => window.location.reload()}
                  className="w-full bg-amber-500 hover:bg-amber-600 text-slate-900 font-bold py-3 rounded-lg active:scale-95 transition mb-2"
                >
                  REFRESH
                </button>
                <button
                  onClick={() => setUpdateModal(false)}
                  className="w-full text-slate-500 hover:text-slate-300 font-medium py-2 rounded-lg transition text-sm"
                >
                  Later
                </button>
              </div>
            </div>
          )}

          {/* Undo Toast */}
          {deletedPlayer && (
            <div
              className="fixed bottom-4 left-1/2 -translate-x-1/2 bg-slate-700 text-white px-4 py-3 rounded-lg shadow-xl flex items-center gap-3 z-50"
              style={{animation: 'slideUp 0.2s ease-out'}}
            >
              <span className="text-sm">Deleted #{deletedPlayer.number}</span>
              <button
                onClick={undoDelete}
                className="bg-amber-500 hover:bg-amber-600 text-slate-900 font-bold px-3 py-1 rounded text-sm flex items-center gap-1 active:scale-95 transition"
              >
                <Undo size={14} />
                Undo
              </button>
              <button
                onClick={() => setDeletedPlayer(null)}
                className="text-slate-400 hover:text-white transition"
              >
                <X size={16} />
              </button>
            </div>
          )}

        </div>
      );
    }

    ReactDOM.render(<SoftballPlayerRater />, document.getElementById('root'));

    // PWA Service Worker Registration and Update Checking
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/rosterrank/service-worker.js')
          .then(registration => {
            console.log('Service Worker registered:', registration);
            
            // Check for updates every 30 seconds for faster deployment
            setInterval(() => {
              registration.update();
            }, 30000);
            
            // Also check on page visibility change (when user returns to tab)
            document.addEventListener('visibilitychange', () => {
              if (!document.hidden) {
                registration.update();
              }
            });

            // Listen for new service worker waiting
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New service worker is ready but waiting
                  console.log('New version available, showing update notification');
                  showUpdateNotification();
                }
              });
            });

            // Listen for controller change (indicates new version activated)
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              console.log('Service worker updated');
            });
          })
          .catch(error => {
            console.error('Service Worker registration failed:', error);
          });
      });

      // Note: Removed auto-refresh on controllerchange to allow update modal to stay visible
      // User must click "REFRESH" in the modal to reload the page

      // Listen for messages from service worker
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'UPDATE_AVAILABLE') {
          showUpdateNotification();
        }
      });
    }

    // Show update notification modal
    function showUpdateNotification() {
      // Call the React function to show the modal
      if (window.showUpdateModal) {
        window.showUpdateModal();
      }
    }
  </script>
</body>
</html>